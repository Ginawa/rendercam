
-- The camera script is fairly light (so far, anyway).

-- 1. It holds the properties so the user can set them in the editor.
-- 2. It updates the camera's position and rotation with the rendercam module.

local rendercam = require "main.rendercam.rendercam"

go.property("active", true)
go.property("nearZ", 1)
go.property("farZ", 1000)
go.property("orthographic", true)
go.property("fov", 1.05)
go.property("orthoScale", 1)

go.property("fixedAspectRatio", false)
-- Using a vector property to set aspectRatio so it can be more accurate.
-- This way you don't end up with 800 x 599.9994812093 px view areas.
go.property("aspectRatio", vmath.vector3(16, 9, 0)) -- only used with a fixed aspect ratio

go.property("viewArea", vmath.vector3(800, 600, 500))
go.property("useViewArea", false)

go.property("expandView", true)
go.property("fixedArea", true)
go.property("fixedWidth", false)
go.property("fixedHeight", false)

local DEFAULT_VIEWDIST = 500 -- arbitrary distance in front of camera used to calculate world view size on window changes
local FORWARDVEC = vmath.vector3(0, 0, -1)
local UPVEC = vmath.vector3(0, 1, 0)
local RIGHTVEC = vmath.vector3(1, 0, 0)


function init(self)
	-- Get initial scale mode
	for i, v in ipairs({ "expandView", "fixedArea", "fixedWidth", "fixedHeight" }) do
		self[v] = self[v] and hash(v)
	end
	self.scaleMode = self.expandView or self.fixedArea or self.fixedWidth or self.fixedHeight -- get first checked
	if not self.scaleMode then self.scaleMode = hash("fixedArea") end

	-- Make sure nearZ and farZ are valid values
	if self.nearZ <= 0 then self.nearZ = 0.1 end
	if self.farZ < 0 then self.farZ = 0.1 end

	-- Turn aspect ratio from x, y into a single number
	self.aspectRatio = self.aspectRatio.x / self.aspectRatio.y

	-- Modify viewArea based on aspect ratio, etc.
	if self.fixedAspectRatio then
		if self.useViewArea then
			-- aspectRatio overrides proportion of viewArea (uses viewArea.x)
			self.viewArea.y = self.viewArea.x / self.aspectRatio
		else
			-- or get fixed aspect viewArea inside current window
			local scale = math.min(rendercam.window.x / self.aspectRatio, rendercam.window.y / 1)
			self.viewArea.x = scale * self.aspectRatio;  self.viewArea.y = scale
		end
	elseif not self.useViewArea then -- not using viewArea and non-fixed aspect ratio
		-- Set viewArea to current window size
		self.viewArea.x = rendercam.window.x;  self.viewArea.y = rendercam.window.y
	end

	if not self.useViewArea then self.viewArea.z = DEFAULT_VIEWDIST end

	-- Get initial vectors & stuff
	self.pos = go.get_world_position()
	self.rot = go.get_world_rotation()
	self.forwardVec = vmath.rotate(self.rot, FORWARDVEC)
	self.upVec = vmath.rotate(self.rot, UPVEC)
	self.rightVec = vmath.rotate(self.rot, RIGHTVEC)
	self.id = go.get_id()

	-- Put all camera data into a table for rendercam module and init camera.
	self.data = {
		active = self.active,
		id = self.id,
		script = msg.url("#"),
		nearZ = self.nearZ,
		farZ = self.farZ,
		pos = self.pos,
		abs_nearZ = self.nearZ,
		abs_farZ = self.farZ,
		rot = self.rot,
		orthographic = self.orthographic,
		fov = self.fov,
		fixedAspectRatio = self.fixedAspectRatio,
		orthoScale = self.orthoScale,
		aspectRatio = self.aspectRatio,
		scaleMode = self.scaleMode,
		useViewArea = self.useViewArea,
		viewArea = self.viewArea,
		halfViewArea = vmath.vector3(self.viewArea) * 0.5,
		forwardVec = self.forwardVec,
		upVec = self.upVec, -- or panning and calculating view matrix
		rightVec = self.rightVec -- for panning
	}
	rendercam.camera_init(self.id, self.data)
end

function update(self, dt)
	-- Update transform stuff
	self.rot = go.get_world_rotation()
	self.data.rot = self.rot
	self.data.forwardVec = vmath.rotate(self.rot, FORWARDVEC)
	self.data.upVec = vmath.rotate(self.rot, UPVEC)
	self.data.rightVec = vmath.rotate(self.rot, RIGHTVEC)
	go.set_position(self.data.pos)

	msg.post("#", "post-update")
end

function on_message(self, message_id, message, sender)
	if message_id == hash("post-update") then
		-- have to update pos after update or it jitters like crazy
		self.data.pos = go.get_world_position()
		self.data.abs_nearZ = self.data.pos.z - self.data.nearZ
		self.data.abs_farZ = self.data.pos.z - self.data.farZ
	end
end
