
local rendercam = require "main.rendercam.rendercam"

local mouse_spos = vmath.vector3() -- screen pos
local mouse_wpos = vmath.vector3() -- world pos

local zstep = 10
local panning = false


function init(self)
	msg.post(".", "acquire_input_focus")
	go.set("logo#sprite", "tint.w", 0.2)
end

function on_input(self, action_id, action)
	if action_id == nil then
		mouse_spos.x = action.screen_x;  mouse_spos.y = action.screen_y

		mouse_wpos = rendercam.screen_to_world(mouse_spos.x, mouse_spos.y)
		msg.post("cursor/main#script", "update pos", {pos = mouse_wpos})

		if panning then
			local last_mouse_wpos = rendercam.screen_to_world(mouse_spos.x - action.screen_dx, mouse_spos.y - action.screen_dy)
			local dv = -(mouse_wpos - last_mouse_wpos)
			rendercam.pan(dv.x, dv.y)
		end

	elseif action_id == hash("mouse wheel up") then
		rendercam.zoom(-zstep)

	elseif action_id == hash("mouse wheel down") then
		rendercam.zoom(zstep)

	elseif action_id == hash("middle click") then
		if action.pressed then
			panning = true
		elseif action.released then
			panning = false
		end

	elseif action_id == hash("space") and action.pressed then
		self.long = not self.long
		rendercam.shake(self.long and 10 or 30, self.long and 4 or 0.3)
		local angle = math.random() * math.pi * 2
		--rendercam.recoil(vmath.vector3(math.cos(angle) * 0, math.sin(angle) * 0, 50), 0.9)

	elseif action_id == hash("enter") and action.pressed then
		go.set_position(vmath.vector3(-500, -500, 900), "camera")

	elseif action_id == hash("escape") then
		msg.post("@system:", "exit", {code = 0})
	end
end

function final(self)
	msg.post(".", "release_input_focus")
end
